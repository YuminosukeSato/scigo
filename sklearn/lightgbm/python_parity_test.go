package lightgbm

import (
	"encoding/json"
	"math"
	"os"
	"path/filepath"
	"testing"

	"gonum.org/v1/gonum/mat"
)

type pyTestData struct {
	ModelFile           string          `json:"model_file"`
	TestSamples         [][]float64     `json:"test_samples"`
	ExpectedPredictions json.RawMessage `json:"expected_predictions"`
}

// loadLocalTestData loads small test fixtures generated by Python under sklearn/lightgbm/testdata.
func loadLocalTestData(t *testing.T, name string) (*pyTestData, error) {
	t.Helper()
	path := filepath.Join("testdata", name+"_test_data.json")
	// Clean the file path to prevent path traversal attacks
	cleanPath := filepath.Clean(path)
	f, err := os.Open(cleanPath)
	if err != nil {
		return nil, err
	}
	defer func() {
		_ = f.Close()
	}()

	var td pyTestData
	if err := json.NewDecoder(f).Decode(&td); err != nil {
		return nil, err
	}
	return &td, nil
}

// decodeExpected decodes expected predictions which can be 1-D or 2-D.
func decodeExpected(t *testing.T, raw json.RawMessage) [][]float64 {
	t.Helper()
	// Try 2-D first
	var twoD [][]float64
	if err := json.Unmarshal(raw, &twoD); err == nil {
		return twoD
	}
	// Fallback to 1-D -> wrap into Nx1
	var oneD []float64
	if err := json.Unmarshal(raw, &oneD); err == nil {
		res := make([][]float64, len(oneD))
		for i, v := range oneD {
			res[i] = []float64{v}
		}
		return res
	}
	t.Fatalf("failed to decode expected predictions: %s", string(raw))
	return nil
}

func asDense(data [][]float64) *mat.Dense {
	if len(data) == 0 {
		return mat.NewDense(0, 0, nil)
	}
	r := len(data)
	c := len(data[0])
	flat := make([]float64, 0, r*c)
	for i := 0; i < r; i++ {
		flat = append(flat, data[i]...)
	}
	return mat.NewDense(r, c, flat)
}

func compareMatrices(t *testing.T, got mat.Matrix, want [][]float64, tol float64) {
	t.Helper()
	gr, gc := got.Dims()
	if gr != len(want) {
		t.Fatalf("row mismatch: got %d want %d", gr, len(want))
	}
	wc := 1
	if len(want) > 0 {
		wc = len(want[0])
	}
	if gc != wc {
		t.Fatalf("col mismatch: got %d want %d", gc, wc)
	}
	for i := 0; i < gr; i++ {
		for j := 0; j < gc; j++ {
			diff := math.Abs(got.At(i, j) - want[i][j])
			if diff > tol {
				t.Fatalf("mismatch at (%d,%d): got %.12f want %.12f diff %.3e (tol %.1e)", i, j, got.At(i, j), want[i][j], diff, tol)
			}
		}
	}
}

// TestPythonParity_Leaves uses the leaves-compatible loader/predictor to verify parity.
func TestPythonParity_Leaves(t *testing.T) {
	cases := []struct {
		name    string
		tol     float64
		isMulti bool
	}{
		{name: "binary", tol: 1e-12},
		{name: "regression", tol: 1e-12},
		{name: "multiclass", tol: 1e-12, isMulti: true},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			td, err := loadLocalTestData(t, tc.name)
			if err != nil {
				t.Skipf("test fixture not found: %v", err)
			}
			// Load model (leaves-compatible text)
			modelPath := filepath.Join("testdata", td.ModelFile)
			lm, err := LoadLeavesModelFromFile(modelPath)
			if err != nil {
				t.Fatalf("failed to load leaves model: %v", err)
			}
			lp := NewLeavesPredictor(lm)

			X := asDense(td.TestSamples)
			got, err := lp.Predict(X)
			if err != nil {
				t.Fatalf("predict failed: %v", err)
			}

			want := decodeExpected(t, td.ExpectedPredictions)
			compareMatrices(t, got, want, tc.tol)
		})
	}
}

// TestPythonParity_JSON uses the JSON dump loader + generic predictor to verify parity.
func TestPythonParity_JSON(t *testing.T) {
	t.Skip("Skipping Python parity tests until v0.7.0 implementation")

	cases := []struct {
		name string
		tol  float64
	}{
		{name: "binary", tol: 1e-12},
		{name: "regression", tol: 1e-12},
		{name: "multiclass", tol: 1e-12},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			td, err := loadLocalTestData(t, tc.name)
			if err != nil {
				t.Skipf("test fixture not found: %v", err)
			}
			// Load JSON model dumped by Python
			jsonPath := filepath.Join("testdata", tc.name+"_model.json")
			m, err := LoadFromJSONFile(jsonPath)
			if err != nil {
				t.Fatalf("failed to load json model: %v", err)
			}
			p := NewPredictor(m)
			p.SetDeterministic(true)

			X := asDense(td.TestSamples)
			got, err := p.Predict(X)
			if err != nil {
				t.Fatalf("predict failed: %v", err)
			}

			want := decodeExpected(t, td.ExpectedPredictions)
			compareMatrices(t, got, want, tc.tol)
		})
	}
}
